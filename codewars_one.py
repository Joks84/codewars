# The Western Suburbs Croquet Club has two categories of membership, Senior and Open. They would like your help
# with an application form that will tell prospective members which category they will be placed.
# To be a senior, a member must be at least 55 years old and have a handicap greater than 7. In this croquet club,
# handicaps range from -2 to +26; the better the player the lower the handicap.
# INPUT
# Input will consist of a list of lists containing two items each. Each list contains information for a single
# potential member. Information consists of an integer for the person's age and an integer for the person's handicap.
# Note for F#: The input will be of (int list list) which is a List<List>

# EXAMPLE INPUT
# [[18, 20],[45, 2],[61, 12],[37, 6],[21, 21],[78, 9]]
# OUTPUT
# Output will consist of a list of string values (in Haskell: Open or Senior) stating whether the respective
# member is to be placed in the senior or open category.
#
# EXAMPLE OUTPUT
# ["Open", "Open", "Senior", "Open", "Open", "Senior"]


def open_or_senior(data):
    print(["Senior" if list[0] >= 55 and list[1] > 7 else "Open" for list in data])

open_or_senior([[53, 23],[64, 1],[51, 23],[72, 8],[66, 22],[10, 24]])


# This time no story, no theory. The examples below show you how to write function accum:
# EXAMPLES:
# accum("abcd") -> "A-Bb-Ccc-Dddd"
# accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
# accum("cwAt") -> "C-Ww-Aaa-Tttt"
# The parameter of accum is a string which includes only letters from a..z and A..Z.

def accum(word):
    result = ""
    for index, letter in enumerate(word, start=1):
        result += (letter*index).capitalize() + "-"
    print(result.strip("-"))

accum('abcd')
accum('RqaEzty')
accum('cwAt')

# You live in the city of Cartesia where all roads are laid out in a perfect grid. You arrived ten minutes too early to
# an appointment, so you decided to take the opportunity to go for a short walk. The city provides its citizens with
# a Walk Generating App on their phones -- everytime you press the button it sends you an array of one-letter strings
# representing directions to walk (eg. ['n', 's', 'w', 'e']). You always walk only a single block for each letter
# (direction) and you know it takes you one minute to traverse one city block, so create a function that will return
# true if the walk the app gives you will take you exactly ten minutes (you don't want to be early or late!) and will, '
# of course, return you to your starting' point. Return false otherwise.
#
# Note: you will always receive a valid array containing a random assortment of direction letters
# ('n', 's', 'e', or 'w' only). It will never give you an empty array (that's not a walk, that's standing still!).
def is_valid_walk(walk):
    if len(walk) == 10:
        if walk.count('n') == walk.count('s') and walk.count('w') == walk.count('e'):
            print(True)
        else:
            print(False)
    print(False)

is_valid_walk(['n', 's', 'e'])
is_valid_walk(['s', 's', 'e', 'e', 'w', 's'])


# Given: an array containing hashes of names
# Return: a string formatted as a list of names separated by commas except for the last two names,
# which should be separated by an ampersand.
# EXAMPLE:
# namelist([ {'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'} ])
# returns 'Bart, Lisa & Maggie'

# namelist([ {'name': 'Bart'}, {'name': 'Lisa'} ])
# returns 'Bart & Lisa'

# namelist([ {'name': 'Bart'} ])
# returns 'Bart'

# namelist([])
# returns ''

def namelist(names):
    words = ""
    if not names:
        print(words)
    else:
        raw = ""
        for item in names:
            for value in item.values():
                if len(names) == 1:
                    words += value
                else:
                    raw += value + " & "
                    words = raw.replace(' & ', ', ', len(names) - 2).strip(' & ')
    print(words)


namelist([{'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'}, {'name': 'Homer'}, {'name': 'Marge'}])
namelist([{'name': 'Bart'}])
namelist([])

# Your goal in this kata is to implement a difference function,
# which subtracts one list from another and returns the result.

# It should remove all values from list a, which are present in list b keeping their order.
# array_diff([1,2],[1]) == [2]

# If a value is present in b, all of its occurrences must be removed from the other:
# array_diff([1,2,2,2,3],[2]) == [1,3]

def array_diff(a, b):
    out = []
    for item in a:
        if not item in b:
            out.append(item)
    print(out)

array_diff([1, 2], [1])
array_diff([1, 2, 2, 2, 3], [2])
array_diff([1, 2, 2], [1])


# This time we want to write calculations using functions and get the results. Let's have a look at some examples:
#
# seven(times(five())) # must return 35
# four(plus(nine())) # must return 13
# eight(minus(three())) # must return 5
# six(divided_by(two())) # must return 3
# Requirements:
#
# There must be a function for each number from 0 ("zero") to 9 ("nine")
# There must be a function for each of the following mathematical operations:
# plus, minus, times, dividedBy (divided_by in Ruby and Python)
# Each calculation consist of exactly one operation and two numbers
# The most outer function represents the left operand, the most inner function represents the right operand
# Division should be integer division. For example, this should return 2, not 2.666666...:
# eight(divided_by(three()))
import math


def my_function(number, func = None):
    if func:
        return func(number)
    else:
        return number

# Numbers
def zero(func=None): return my_function(0, func)
def one(func=None): return my_function(1, func)
def two(func=None): return my_function(2, func)
def three(func=None): return my_function(3, func)
def four(func=None): return my_function(4, func)
def five(func=None): return my_function(5, func)
def six(func=None): return my_function(6, func)
def seven(func=None): return my_function(7, func)
def eight(func=None): return my_function(8, func)
def nine(func=None): return my_function(9, func)

# Calculations
def times(x): return lambda y: y * x
def divided_by(x): return lambda y: math.floor(y/x)
def plus(x): return lambda y: y + x
def minus(x): return lambda y: y - x

print(seven(times(five())))
print(seven(times(five())))
print(four(plus(nine())))
print(eight(minus(three())))
print(six(divided_by(two())))
